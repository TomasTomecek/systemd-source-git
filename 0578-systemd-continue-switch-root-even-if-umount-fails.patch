From 94467d852e939669c76fdca0fddf1944e1d6fecb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Zbigniew=20J=C4=99drzejewski-Szmek?= <zbyszek@in.waw.pl>
Date: Thu, 16 Oct 2014 19:12:55 -0500
Subject: [PATCH] systemd: continue switch-root even if umount fails

Leaving the old root around seems better than aborting the
switch.
---
 src/core/main.c          |  2 +-
 src/shared/switch-root.c | 15 +++++++--------
 2 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/src/core/main.c b/src/core/main.c
index 44373cc7ef..0388f46c36 100644
--- a/src/core/main.c
+++ b/src/core/main.c
@@ -1857,7 +1857,7 @@ finish:
                         /* And switch root with MS_MOVE, because we remove the old directory afterwards and detach it. */
                         r = switch_root(switch_root_dir, "/mnt", true, MS_MOVE);
                         if (r < 0)
-                                log_error("Failed to switch root, ignoring: %s", strerror(-r));
+                                log_error("Failed to switch root, trying to continue: %s", strerror(-r));
                 }
 
                 args_size = MAX(6, argc+1);
diff --git a/src/shared/switch-root.c b/src/shared/switch-root.c
index 5f075e6003..bac0e5c349 100644
--- a/src/shared/switch-root.c
+++ b/src/shared/switch-root.c
@@ -62,10 +62,9 @@ int switch_root(const char *new_root, const char *oldroot, bool detach_oldroot,
                 return -errno;
         }
 
-        /* Work-around for a kernel bug: for some reason the kernel
-         * refuses switching root if any file systems are mounted
-         * MS_SHARED. Hence remount them MS_PRIVATE here as a
-         * work-around.
+        /* Work-around for kernel design: the kernel refuses switching
+         * root if any file systems are mounted MS_SHARED. Hence
+         * remount them MS_PRIVATE here as a work-around.
          *
          * https://bugzilla.redhat.com/show_bug.cgi?id=847418 */
         if (mount(NULL, "/", NULL, MS_REC|MS_PRIVATE, NULL) < 0)
@@ -128,10 +127,10 @@ int switch_root(const char *new_root, const char *oldroot, bool detach_oldroot,
 
                 /* Immediately get rid of the old root, if detach_oldroot is set.
                  * Since we are running off it we need to do this lazily. */
-                if (detach_oldroot && umount2(oldroot, MNT_DETACH) < 0) {
-                        log_error("Failed to umount old root dir %s: %m", oldroot);
-                        return -errno;
-                }
+                if (detach_oldroot && umount2(oldroot, MNT_DETACH) < 0)
+                        log_error("Failed to lazily umount old root dir %s, %s: %m",
+                                  oldroot,
+                                  errno == ENOENT ? "ignoring" : "leaving it around");
 
         } else if (mount(new_root, "/", NULL, MS_MOVE, NULL) < 0) {
                 log_error("Failed to mount moving %s to /: %m", new_root);
