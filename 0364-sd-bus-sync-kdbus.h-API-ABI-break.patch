From f8c2425287c8362ae3a3c9acfb9e23a16862b38a Mon Sep 17 00:00:00 2001
From: Daniel Mack <daniel@zonque.org>
Date: Mon, 22 Sep 2014 18:20:14 +0200
Subject: [PATCH] sd-bus: sync kdbus.h (API+ABI break)

The kdbus logic name registry logic was changed to transport the actual
name to acquire, release or report in a kdbus item.

This brings the name API a little more in line with other calls, and allows
for later augmentation.

Follow that change on the systemd side.
---
 src/bus-proxyd/bus-proxyd.c         |  9 ++++++---
 src/libsystemd/sd-bus/bus-control.c | 30 ++++++++++++++++++++++--------
 src/libsystemd/sd-bus/kdbus.h       | 23 ++++++++++-------------
 3 files changed, 38 insertions(+), 24 deletions(-)

diff --git a/src/bus-proxyd/bus-proxyd.c b/src/bus-proxyd/bus-proxyd.c
index d35d7f63b2..a5387bb234 100644
--- a/src/bus-proxyd/bus-proxyd.c
+++ b/src/bus-proxyd/bus-proxyd.c
@@ -743,12 +743,15 @@ static int process_driver(sd_bus *a, sd_bus *b, sd_bus_message *m) {
                 name_list = (struct kdbus_name_list *) ((uint8_t *) a->kdbus_buffer + cmd.offset);
 
                 KDBUS_ITEM_FOREACH(name, name_list, names) {
+                        const char *entry_name = NULL;
+                        struct kdbus_item *item;
                         char *n;
 
-                        if (name->size <= sizeof(*name))
-                                continue;
+                        KDBUS_ITEM_FOREACH(item, name, items)
+                                if (item->type == KDBUS_ITEM_NAME)
+                                        entry_name = item->str;
 
-                        if (!streq(name->name, arg0))
+                        if (!streq_ptr(entry_name, arg0))
                                 continue;
 
                         if (asprintf(&n, ":1.%llu", (unsigned long long) name->owner_id) < 0) {
diff --git a/src/libsystemd/sd-bus/bus-control.c b/src/libsystemd/sd-bus/bus-control.c
index 5ac48c081f..50b662f85d 100644
--- a/src/libsystemd/sd-bus/bus-control.c
+++ b/src/libsystemd/sd-bus/bus-control.c
@@ -59,11 +59,14 @@ static int bus_request_name_kernel(sd_bus *bus, const char *name, uint64_t flags
         assert(name);
 
         l = strlen(name);
-        size = offsetof(struct kdbus_cmd_name, name) + l + 1;
+        size = offsetof(struct kdbus_cmd_name, items) + KDBUS_ITEM_SIZE(l + 1);
         n = alloca0_align(size, 8);
         n->size = size;
         kdbus_translate_request_name_flags(flags, (uint64_t *) &n->flags);
-        memcpy(n->name, name, l+1);
+
+        n->items[0].size = KDBUS_ITEM_HEADER_SIZE + l + 1;
+        n->items[0].type = KDBUS_ITEM_NAME;
+        memcpy(n->items[0].str, name, l+1);
 
 #ifdef HAVE_VALGRIND_MEMCHECK_H
         VALGRIND_MAKE_MEM_DEFINED(n, n->size);
@@ -144,16 +147,20 @@ _public_ int sd_bus_request_name(sd_bus *bus, const char *name, uint64_t flags)
 
 static int bus_release_name_kernel(sd_bus *bus, const char *name) {
         struct kdbus_cmd_name *n;
-        size_t l;
+        size_t size, l;
         int r;
 
         assert(bus);
         assert(name);
 
         l = strlen(name);
-        n = alloca0_align(offsetof(struct kdbus_cmd_name, name) + l + 1, 8);
-        n->size = offsetof(struct kdbus_cmd_name, name) + l + 1;
-        memcpy(n->name, name, l+1);
+        size = offsetof(struct kdbus_cmd_name, items) + KDBUS_ITEM_SIZE(l + 1);
+        n = alloca0_align(size, 8);
+        n->size = size;
+
+        n->items[0].size = KDBUS_ITEM_HEADER_SIZE + l + 1;
+        n->items[0].type = KDBUS_ITEM_NAME;
+        memcpy(n->items[0].str, name, l+1);
 
 #ifdef HAVE_VALGRIND_MEMCHECK_H
         VALGRIND_MAKE_MEM_DEFINED(n, n->size);
@@ -235,6 +242,9 @@ static int kernel_get_list(sd_bus *bus, uint64_t flags, char ***x) {
 
         KDBUS_ITEM_FOREACH(name, name_list, names) {
 
+                struct kdbus_item *item;
+                const char *entry_name = NULL;
+
                 if ((flags & KDBUS_NAME_LIST_UNIQUE) && name->owner_id != previous_id) {
                         char *n;
 
@@ -248,8 +258,12 @@ static int kernel_get_list(sd_bus *bus, uint64_t flags, char ***x) {
                         previous_id = name->owner_id;
                 }
 
-                if (name->size > sizeof(*name) && service_name_is_valid(name->name)) {
-                        r = strv_extend(x, name->name);
+                KDBUS_ITEM_FOREACH(item, name, items)
+                        if (item->type == KDBUS_ITEM_NAME)
+                                entry_name = item->str;
+
+                if (entry_name && service_name_is_valid(entry_name)) {
+                        r = strv_extend(x, entry_name);
                         if (r < 0)
                                 return -ENOMEM;
                 }
diff --git a/src/libsystemd/sd-bus/kdbus.h b/src/libsystemd/sd-bus/kdbus.h
index 7379b3d442..0718b8497a 100644
--- a/src/libsystemd/sd-bus/kdbus.h
+++ b/src/libsystemd/sd-bus/kdbus.h
@@ -17,11 +17,8 @@
 #ifndef _KDBUS_UAPI_H_
 #define _KDBUS_UAPI_H_
 
-#ifndef __KERNEL__
-#include <sys/ioctl.h>
-#include <sys/types.h>
+#include <linux/ioctl.h>
 #include <linux/types.h>
-#endif
 
 #define KDBUS_IOCTL_MAGIC		0x95
 #define KDBUS_SRC_ID_KERNEL		(0)
@@ -121,7 +118,7 @@ struct kdbus_timestamp {
 /**
  * struct kdbus_vec - I/O vector for kdbus payload items
  * @size:		The size of the vector
- * @address:		Memory address for memory addresses
+ * @address:		Memory address of data buffer
  * @offset:		Offset in the in-message payload memory,
  *			relative to the message head
  *
@@ -160,7 +157,7 @@ struct kdbus_bloom_filter {
  * struct kdbus_memfd - a kdbus memfd
  * @size:		The memfd's size
  * @fd:			The file descriptor number
- * @__pad:		Padding to ensure proper alignement and size
+ * @__pad:		Padding to ensure proper alignment and size
  *
  * Attached to:
  *   KDBUS_ITEM_PAYLOAD_MEMFD
@@ -477,7 +474,7 @@ enum kdbus_policy_type {
 
 /**
  * enum kdbus_hello_flags - flags for struct kdbus_cmd_hello
- * @KDBUS_HELLO_ACCEPT_FD:	The connection allows the receiving of
+ * @KDBUS_HELLO_ACCEPT_FD:	The connection allows the reception of
  *				any passed file descriptors
  * @KDBUS_HELLO_ACTIVATOR:	Special-purpose connection which registers
  *				a well-know name for a process to be started
@@ -533,8 +530,7 @@ enum kdbus_attach_flags {
 /**
  * struct kdbus_cmd_hello - struct to say hello to kdbus
  * @size:		The total size of the structure
- * @conn_flags:		Connection flags (KDBUS_HELLO_*). The kernel will
- *			return its capabilities in that field.
+ * @conn_flags:		Connection flags (KDBUS_HELLO_*).
  * @attach_flags:	Mask of metadata to attach to each message sent
  *			(KDBUS_ATTACH_*)
  * @bus_flags:		The flags field copied verbatim from the original
@@ -608,9 +604,10 @@ enum kdbus_name_flags {
  * struct kdbus_cmd_name - struct to describe a well-known name
  * @size:		The total size of the struct
  * @flags:		Flags for a name entry (KDBUS_NAME_*)
- * @owner_id:		The current owner of the name.
+ * @owner_id:		The current owner of the name
  * @conn_flags:		The flags of the owning connection (KDBUS_HELLO_*)
- * @name:		The well-known name
+ * @items:		Item list, containing the well-known name as
+ *			KDBUS_ITEM_NAME
  *
  * This structure is used with the KDBUS_CMD_NAME_ACQUIRE ioctl.
  */
@@ -619,7 +616,7 @@ struct kdbus_cmd_name {
 	__u64 flags;
 	__u64 owner_id;
 	__u64 conn_flags;
-	char name[0];
+	struct kdbus_item items[0];
 } __attribute__((aligned(8)));
 
 /**
@@ -808,7 +805,7 @@ enum kdbus_ioctl_type {
 	KDBUS_CMD_NAME_RELEASE =	_IOW(KDBUS_IOCTL_MAGIC, 0x51,
 					     struct kdbus_cmd_name),
 	KDBUS_CMD_NAME_LIST =		_IOWR(KDBUS_IOCTL_MAGIC, 0x52,
-					     struct kdbus_cmd_name_list),
+					      struct kdbus_cmd_name_list),
 
 	KDBUS_CMD_CONN_INFO =		_IOWR(KDBUS_IOCTL_MAGIC, 0x60,
 					      struct kdbus_cmd_conn_info),
