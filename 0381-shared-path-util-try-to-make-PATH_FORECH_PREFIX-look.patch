From 4a690c47260ca507bbcf92e2a68f66d3ec9a23fb Mon Sep 17 00:00:00 2001
From: Tom Gundersen <teg@jklm.no>
Date: Thu, 25 Sep 2014 16:12:41 +0200
Subject: [PATCH] shared: path-util - try to make PATH_FORECH_PREFIX look less
 wrong

We replace the idiom "X && !(*foo = 0)" with "X && ((*foo = 0), true)".

This is not a functional change, but should hopefully make it less
likely that people and static analyzers believe there is a typo here
(i.e., to make it clear that the intention was not "X && *foo != 0").

Thanks to David Herrmann for the suggestion.
---
 src/shared/path-util.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/shared/path-util.h b/src/shared/path-util.h
index d85291bb44..8d171a57ec 100644
--- a/src/shared/path-util.h
+++ b/src/shared/path-util.h
@@ -65,8 +65,8 @@ int fsck_exists(const char *fstype);
  * the tree, to root. Also returns "" (and not "/"!) for the root
  * directory. Excludes the specified directory itself */
 #define PATH_FOREACH_PREFIX(prefix, path) \
-        for (char *_slash = ({ path_kill_slashes(strcpy(prefix, path)); streq(prefix, "/") ? NULL : strrchr(prefix, '/'); }); _slash && !(*_slash = 0); _slash = strrchr((prefix), '/'))
+        for (char *_slash = ({ path_kill_slashes(strcpy(prefix, path)); streq(prefix, "/") ? NULL : strrchr(prefix, '/'); }); _slash && ((*_slash = 0), true); _slash = strrchr((prefix), '/'))
 
 /* Same as PATH_FOREACH_PREFIX but also includes the specified path itself */
 #define PATH_FOREACH_PREFIX_MORE(prefix, path) \
-        for (char *_slash = ({ path_kill_slashes(strcpy(prefix, path)); if (streq(prefix, "/")) prefix[0] = 0; strrchr(prefix, 0); }); _slash && !(*_slash = 0); _slash = strrchr((prefix), '/'))
+        for (char *_slash = ({ path_kill_slashes(strcpy(prefix, path)); if (streq(prefix, "/")) prefix[0] = 0; strrchr(prefix, 0); }); _slash && ((*_slash = 0), true); _slash = strrchr((prefix), '/'))
