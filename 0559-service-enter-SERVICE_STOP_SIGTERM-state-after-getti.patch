From 6041a7ee2c1bbff6301082f192fc1b0882400d42 Mon Sep 17 00:00:00 2001
From: Michal Schmidt <mschmidt@redhat.com>
Date: Thu, 9 Oct 2014 17:27:57 +0200
Subject: [PATCH] service: enter SERVICE_STOP_SIGTERM state after getting
 "STOPPING=1"

SERVICE_STOP would mean we're running the ExecStop command. That's not
the case with "STOPPING=1".
Instead we should enter the same state as if we just told the service
to stop, i.e. SERVICE_STOP_SIGTERM.

This fixes a bug where voluntarily exiting services would hang around in
deactivating state until timeout.
---
 src/core/service.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/core/service.c b/src/core/service.c
index 395e0ca8c6..f551061366 100644
--- a/src/core/service.c
+++ b/src/core/service.c
@@ -1227,7 +1227,8 @@ static void service_enter_stop_by_notify(Service *s) {
         if (s->timeout_stop_usec > 0)
                 service_arm_timer(s, s->timeout_stop_usec);
 
-        service_set_state(s, SERVICE_STOP);
+        /* The service told us it's stopping, so it's as if we SIGTERM'd it. */
+        service_set_state(s, SERVICE_STOP_SIGTERM);
 }
 
 static void service_enter_stop(Service *s, ServiceResult f) {
