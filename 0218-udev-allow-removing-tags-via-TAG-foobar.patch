From 8e3ba3772cadf6a8292b0da533062dd4d377af67 Mon Sep 17 00:00:00 2001
From: David Herrmann <dh.herrmann@gmail.com>
Date: Thu, 11 Sep 2014 13:25:21 +0200
Subject: [PATCH] udev: allow removing tags via TAG-="foobar"

This extends the udev parser to support OP_REMOVE (-=) and adds support
for TAG-= to remove previously set tags. We don't fail if the tag didn't
exist.

This is pretty handy if we ship default rules for seat-assignments and
users want to exclude specific devices from that. They can easily add
rules that drop any automatically added "seat" tags again.
---
 man/udev.xml                  |  7 ++++
 src/libudev/libudev-device.c  | 21 +++++++++++-
 src/libudev/libudev-private.h |  1 +
 src/udev/udev-rules.c         | 78 +++++++++++++++++++++++++++++++++++++++++--
 4 files changed, 103 insertions(+), 4 deletions(-)

diff --git a/man/udev.xml b/man/udev.xml
index 2948b9ce2b..d77cbb0e6e 100644
--- a/man/udev.xml
+++ b/man/udev.xml
@@ -114,6 +114,13 @@
         </varlistentry>
 
         <varlistentry>
+          <term><literal>-=</literal></term>
+          <listitem>
+            <para>Remove the value from a key that holds a list of entries.</para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
           <term><literal>:=</literal></term>
           <listitem>
             <para>Assign  a  value  to  a key finally; disallow any later changes.</para>
diff --git a/src/libudev/libudev-device.c b/src/libudev/libudev-device.c
index f26a4c44b5..d61a2ad8f4 100644
--- a/src/libudev/libudev-device.c
+++ b/src/libudev/libudev-device.c
@@ -1732,9 +1732,14 @@ void udev_device_set_is_initialized(struct udev_device *udev_device)
         udev_device->is_initialized = true;
 }
 
+static bool is_valid_tag(const char *tag)
+{
+        return !strchr(tag, ':') && !strchr(tag, ' ');
+}
+
 int udev_device_add_tag(struct udev_device *udev_device, const char *tag)
 {
-        if (strchr(tag, ':') != NULL || strchr(tag, ' ') != NULL)
+        if (!is_valid_tag(tag))
                 return -EINVAL;
         udev_device->tags_uptodate = false;
         if (udev_list_entry_add(&udev_device->tags_list, tag, NULL) != NULL)
@@ -1742,6 +1747,20 @@ int udev_device_add_tag(struct udev_device *udev_device, const char *tag)
         return -ENOMEM;
 }
 
+void udev_device_remove_tag(struct udev_device *udev_device, const char *tag)
+{
+        struct udev_list_entry *e;
+
+        if (!is_valid_tag(tag))
+                return;
+        e = udev_list_get_entry(&udev_device->tags_list);
+        e = udev_list_entry_get_by_name(e, tag);
+        if (e) {
+                udev_device->tags_uptodate = false;
+                udev_list_entry_delete(e);
+        }
+}
+
 void udev_device_cleanup_tags_list(struct udev_device *udev_device)
 {
         udev_device->tags_uptodate = false;
diff --git a/src/libudev/libudev-private.h b/src/libudev/libudev-private.h
index cd1c1fb8b3..35ea7ba44c 100644
--- a/src/libudev/libudev-private.h
+++ b/src/libudev/libudev-private.h
@@ -73,6 +73,7 @@ const char *udev_device_get_devpath_old(struct udev_device *udev_device);
 const char *udev_device_get_id_filename(struct udev_device *udev_device);
 void udev_device_set_is_initialized(struct udev_device *udev_device);
 int udev_device_add_tag(struct udev_device *udev_device, const char *tag);
+void udev_device_remove_tag(struct udev_device *udev_device, const char *tag);
 void udev_device_cleanup_tags_list(struct udev_device *udev_device);
 usec_t udev_device_get_usec_initialized(struct udev_device *udev_device);
 void udev_device_set_usec_initialized(struct udev_device *udev_device, usec_t usec_initialized);
diff --git a/src/udev/udev-rules.c b/src/udev/udev-rules.c
index 6de7511c7d..9514dde751 100644
--- a/src/udev/udev-rules.c
+++ b/src/udev/udev-rules.c
@@ -82,7 +82,7 @@ static unsigned int rules_add_string(struct udev_rules *rules, const char *s) {
         return strbuf_add_string(rules->strbuf, s, strlen(s));
 }
 
-/* KEY=="", KEY!="", KEY+="", KEY="", KEY:="" */
+/* KEY=="", KEY!="", KEY+="", KEY-="", KEY="", KEY:="" */
 enum operation_type {
         OP_UNSET,
 
@@ -91,6 +91,7 @@ enum operation_type {
         OP_MATCH_MAX,
 
         OP_ADD,
+        OP_REMOVE,
         OP_ASSIGN,
         OP_ASSIGN_FINAL,
 };
@@ -224,6 +225,7 @@ static const char *operation_str(enum operation_type type) {
                 [OP_MATCH_MAX] =        "MATCH_MAX",
 
                 [OP_ADD] =              "add",
+                [OP_REMOVE] =           "remove",
                 [OP_ASSIGN] =           "assign",
                 [OP_ASSIGN_FINAL] =     "assign-final",
 }        ;
@@ -761,7 +763,7 @@ static int get_key(struct udev *udev, char **line, char **key, enum operation_ty
                         break;
                 if (linepos[0] == '=')
                         break;
-                if ((linepos[0] == '+') || (linepos[0] == '!') || (linepos[0] == ':'))
+                if ((linepos[0] == '+') || (linepos[0] == '-') || (linepos[0] == '!') || (linepos[0] == ':'))
                         if (linepos[1] == '=')
                                 break;
         }
@@ -785,6 +787,9 @@ static int get_key(struct udev *udev, char **line, char **key, enum operation_ty
         } else if (linepos[0] == '+' && linepos[1] == '=') {
                 *op = OP_ADD;
                 linepos += 2;
+        } else if (linepos[0] == '-' && linepos[1] == '=') {
+                *op = OP_REMOVE;
+                linepos += 2;
         } else if (linepos[0] == '=') {
                 *op = OP_ASSIGN;
                 linepos++;
@@ -1121,6 +1126,10 @@ static int add_rule(struct udev_rules *rules, char *line,
                                 log_error("error parsing ATTR attribute");
                                 goto invalid;
                         }
+                        if (op == OP_REMOVE) {
+                                log_error("invalid ATTR operation");
+                                goto invalid;
+                        }
                         if (op < OP_MATCH_MAX) {
                                 rule_add_key(&rule_tmp, TK_M_ATTR, op, value, attr);
                         } else {
@@ -1135,6 +1144,10 @@ static int add_rule(struct udev_rules *rules, char *line,
                                 log_error("error parsing SECLABEL attribute");
                                 goto invalid;
                         }
+                        if (op == OP_REMOVE) {
+                                log_error("invalid SECLABEL operation");
+                                goto invalid;
+                        }
 
                         rule_add_key(&rule_tmp, TK_A_SECLABEL, op, value, attr);
                         continue;
@@ -1202,6 +1215,10 @@ static int add_rule(struct udev_rules *rules, char *line,
                                 log_error("error parsing ENV attribute");
                                 goto invalid;
                         }
+                        if (op == OP_REMOVE) {
+                                log_error("invalid ENV operation");
+                                goto invalid;
+                        }
                         if (op < OP_MATCH_MAX) {
                                 if (rule_add_key(&rule_tmp, TK_M_ENV, op, value, attr) != 0)
                                         goto invalid;
@@ -1242,6 +1259,10 @@ static int add_rule(struct udev_rules *rules, char *line,
                 }
 
                 if (streq(key, "PROGRAM")) {
+                        if (op == OP_REMOVE) {
+                                log_error("invalid PROGRAM operation");
+                                goto invalid;
+                        }
                         rule_add_key(&rule_tmp, TK_M_PROGRAM, op, value, NULL);
                         continue;
                 }
@@ -1261,6 +1282,10 @@ static int add_rule(struct udev_rules *rules, char *line,
                                 log_error("IMPORT{} type missing, ignoring IMPORT %s:%u", filename, lineno);
                                 continue;
                         }
+                        if (op == OP_REMOVE) {
+                                log_error("invalid IMPORT operation");
+                                goto invalid;
+                        }
                         if (streq(attr, "program")) {
                                 /* find known built-in command */
                                 if (value[0] != '/') {
@@ -1316,6 +1341,10 @@ static int add_rule(struct udev_rules *rules, char *line,
                         attr = get_key_attribute(rules->udev, key + strlen("RUN"));
                         if (attr == NULL)
                                 attr = "program";
+                        if (op == OP_REMOVE) {
+                                log_error("invalid RUN operation");
+                                goto invalid;
+                        }
 
                         if (streq(attr, "builtin")) {
                                 enum udev_builtin_cmd cmd = udev_builtin_lookup(value);
@@ -1336,21 +1365,37 @@ static int add_rule(struct udev_rules *rules, char *line,
                 }
 
                 if (streq(key, "WAIT_FOR") || streq(key, "WAIT_FOR_SYSFS")) {
+                        if (op == OP_REMOVE) {
+                                log_error("invalid WAIT_FOR/WAIT_FOR_SYSFS operation");
+                                goto invalid;
+                        }
                         rule_add_key(&rule_tmp, TK_M_WAITFOR, 0, value, NULL);
                         continue;
                 }
 
                 if (streq(key, "LABEL")) {
+                        if (op == OP_REMOVE) {
+                                log_error("invalid LABEL operation");
+                                goto invalid;
+                        }
                         rule_tmp.rule.rule.label_off = rules_add_string(rules, value);
                         continue;
                 }
 
                 if (streq(key, "GOTO")) {
+                        if (op == OP_REMOVE) {
+                                log_error("invalid GOTO operation");
+                                goto invalid;
+                        }
                         rule_add_key(&rule_tmp, TK_A_GOTO, 0, value, NULL);
                         continue;
                 }
 
                 if (startswith(key, "NAME")) {
+                        if (op == OP_REMOVE) {
+                                log_error("invalid NAME operation");
+                                goto invalid;
+                        }
                         if (op < OP_MATCH_MAX) {
                                 rule_add_key(&rule_tmp, TK_M_NAME, op, value, NULL);
                         } else {
@@ -1371,6 +1416,10 @@ static int add_rule(struct udev_rules *rules, char *line,
                 }
 
                 if (streq(key, "SYMLINK")) {
+                        if (op == OP_REMOVE) {
+                                log_error("invalid SYMLINK operation");
+                                goto invalid;
+                        }
                         if (op < OP_MATCH_MAX)
                                 rule_add_key(&rule_tmp, TK_M_DEVLINK, op, value, NULL);
                         else
@@ -1383,6 +1432,11 @@ static int add_rule(struct udev_rules *rules, char *line,
                         uid_t uid;
                         char *endptr;
 
+                        if (op == OP_REMOVE) {
+                                log_error("invalid OWNER operation");
+                                goto invalid;
+                        }
+
                         uid = strtoul(value, &endptr, 10);
                         if (endptr[0] == '\0') {
                                 rule_add_key(&rule_tmp, TK_A_OWNER_ID, op, NULL, &uid);
@@ -1400,6 +1454,11 @@ static int add_rule(struct udev_rules *rules, char *line,
                         gid_t gid;
                         char *endptr;
 
+                        if (op == OP_REMOVE) {
+                                log_error("invalid GROUP operation");
+                                goto invalid;
+                        }
+
                         gid = strtoul(value, &endptr, 10);
                         if (endptr[0] == '\0') {
                                 rule_add_key(&rule_tmp, TK_A_GROUP_ID, op, NULL, &gid);
@@ -1417,6 +1476,11 @@ static int add_rule(struct udev_rules *rules, char *line,
                         mode_t mode;
                         char *endptr;
 
+                        if (op == OP_REMOVE) {
+                                log_error("invalid MODE operation");
+                                goto invalid;
+                        }
+
                         mode = strtol(value, &endptr, 8);
                         if (endptr[0] == '\0')
                                 rule_add_key(&rule_tmp, TK_A_MODE_ID, op, NULL, &mode);
@@ -1429,6 +1493,11 @@ static int add_rule(struct udev_rules *rules, char *line,
                 if (streq(key, "OPTIONS")) {
                         const char *pos;
 
+                        if (op == OP_REMOVE) {
+                                log_error("invalid OPTIONS operation");
+                                goto invalid;
+                        }
+
                         pos = strstr(value, "link_priority=");
                         if (pos != NULL) {
                                 int prio = atoi(&pos[strlen("link_priority=")]);
@@ -2320,7 +2389,10 @@ int udev_rules_apply_to_event(struct udev_rules *rules,
                                 log_error("ignoring invalid tag name '%s'", tag);
                                 break;
                         }
-                        udev_device_add_tag(event->dev, tag);
+                        if (cur->key.op == OP_REMOVE)
+                                udev_device_remove_tag(event->dev, tag);
+                        else
+                                udev_device_add_tag(event->dev, tag);
                         break;
                 }
                 case TK_A_NAME: {
