From 430e21c2f7e77d600257ead56419f511e48e854a Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Thu, 21 Aug 2014 17:20:19 +0200
Subject: [PATCH] bus: when terminating our bus-actviated services that
 exit-on-idle send STOPPING=1 via sd_notify()

This should fix a race where a service thatis idle drops its name, and
is immediately requested by another client, which causes dbus-daemon to
ask systemd to activate it again, but since systemd still assumes it is
running it won't do anything.
---
 src/libsystemd/sd-bus/bus-util.c | 16 ++++++++++++----
 1 file changed, 12 insertions(+), 4 deletions(-)

diff --git a/src/libsystemd/sd-bus/bus-util.c b/src/libsystemd/sd-bus/bus-util.c
index 475ed34a53..c97bf7d99d 100644
--- a/src/libsystemd/sd-bus/bus-util.c
+++ b/src/libsystemd/sd-bus/bus-util.c
@@ -22,6 +22,8 @@
 #include <sys/socket.h>
 #include <sys/capability.h>
 
+#include "systemd/sd-daemon.h"
+
 #include "util.h"
 #include "strv.h"
 #include "macro.h"
@@ -128,11 +130,17 @@ int bus_event_loop_with_idle(
                         if (r == -EBUSY)
                                 continue;
 
+                        /* Fallback for dbus1 connections: we
+                         * unregister the name and wait for the
+                         * response to come through for it */
                         if (r == -ENOTSUP) {
-                                /* Fallback for dbus1 connections: we
-                                 * unregister the name and wait for
-                                 * the response to come through for
-                                 * it */
+
+                                /* Inform the service manager that we
+                                 * are going down, so that it will
+                                 * queue all further start requests,
+                                 * instead of assuming we are already
+                                 * running. */
+                                sd_notify(false, "STOPPING=1");
 
                                 r = bus_async_unregister_and_exit(e, bus, name);
                                 if (r < 0)
